# 3. SQL 语句（MySQL）

# SQL语句的分类

-   1\. **DQL**：数据查询语言
    -   select：查询
-   2\. **DML**：数据操作语言，操作表数据
    -   insert：增
    -   delete：删
    -   update：改
-   3\. **DDL**：数据定义语言，操作表结构
    -   create：新建
    -   drop：删除
    -   alter：修改
-   4\. **TCl**：事物控制语言
    -   commit：事物提交
    -   rollback：事物回滚
-   5\. **DCL**：数据控制语言
    -   grant：授权
    -   revoke：撤消权限

# 1. 数据库操作

## 1.1 创建数据库

```sql
create database <数据库名> 
  [character set <utf8>]    -- 指定字符集（默认utf8）
  [collate utf8_bin];       -- 指定字符校验规则

```

指定排序规则（字符校验规则）：

> utf8\_bin（区分大小写）
> utf8\_general\_ci（不区分大小写，默认规则）

使用`` ` ``将数据库名括起来，可以规避和关键字重名、标识符有空格的情况。

> 如：`` create database `数据库名` ``

## 1.2 查看数据库

查看所有数据库：

```sql
show databases;
```

选择数据库：

```sql
use <数据库名>;
```

显示当前数据库中的表：

```sql
show tables;
```

查看当前使用的数据库：

```sql
select database();
```

查看创建数据库用的sql语句：

```sql
show create database <数据库名>;
```

查看建表使用的 sql 语句：

```sql
show create table <表名>;
```

## 1.3 删除数据库

```sql
drop database <数据库名>;
```

## 1.4 备份数据库

备份数据库：

> 在系统命令行中执行，可以同时导出多个数据库。

```bash
mysqldump -u <用户名> -p -B <数据库名> > *.sql
```

还原数据库（mysql中执行）：

```sql
source <*.sql>    -- 路径不能有中文
```

备份数据库中的表：

```bash
mysqldump -u <用户名> -p <数据库名> 表1 表2 > *.sql
```

# 2. 表操作

## 2.1 创建表

```sql
create table <表名> (
  字段名1 类型(长度) [列级约束],
  [表级约束 (字段)],
  ...
) [character set <字符集>] [collate <校对规则>] [engine <引擎>];  -- 默认与数据库相同

```

查看创建表所用的SQL语句：

```sql
show create table <表名>;
```

### 2.1.1 数据类型

定义无符号类型：

```sql
<字段名> <类型> unsigned
```

-   **整型**
    | **tinyint**   | 1 字节 |
    | ------------- | ---- |
    | **smallint**  | 2 字节 |
    | **mediumint** | 3 字节 |
    | **int**       | 4 字节 |
    | **bigint**    | 8 字节 |
    | **bit(M)**    | 指定长度 |
-   **浮点型**
    | **float**        | 4字节            |
    | ---------------- | -------------- |
    | **double**       | 8字节            |
    | **decimal(M,N)** | 指定长度（总长度, 小数位） |
-   **文本类型**

    注意：
    1.  在utf-8中汉字占3个字节，在MySQL中汉字算一个字符。
    2.  char的查询速度比varchar快，varchar比char更省空间。
    > M为字符个数。
    | **char(M)**    | 0\~255 字符                |
    | -------------- | ------------------------ |
    | **varchar(M)** | 0\~65535 字节，可变长度（根据内容决定） |
    | **text**       | 0\~65535 字节              |
    | **longtext**   | 0\~2^32-1 字节             |
-   **二进制数据类型**
    | **blob**     | 0\~25535 字节  |
    | ------------ | ------------ |
    | **longblob** | 0\~2^32-1 字节 |
-   **日期类型**
    | **date**      | 日期，3 字节                                                     |
    | ------------- | ----------------------------------------------------------- |
    | **time**      | 时间，3字节                                                      |
    | **datetime**  | 日期时间，8字节（格式：`'YYYY-MM-DD HH:mm:ss'`）                        |
    | **timestamp** | 时间戳，4字节（可以自动更新）&#xA;`DEFAULT CURRENT_TIMESTAMP`  默认值设为当前时间。 |

### 2.1.2 约束

> 约束用来保证数据的完整性和有效性。

-   非空约束：`not null`，字段不能为NULL（空字符串不等于NULL）。
-   唯一性约束：`unique`，字段不能重复（可以为NULL）。
-   检查约束：`check`，要求字段必须满足指定条件。
    > 在MySQL 8.0.15以前版本，只支持检查约束语法。8.0.16开始支持约束功能。
-   默认值约束：`default`，当输入为空时，使用默认值填充。
    -   `DEFAULT CURRENT_TIMESTAMP`：默认值为当前时间戳。
-   主键约束：`primary key`，不能重复和为空，一张表只能有一个主键。
-   外键约束：`foreign key`，插入的字段在主表中必须存在（当前表为从表）。
    > 定义外键约束的表为从表，外键引用的表为主表。
    -   注意：
        -   主表被引用字段必须有主键约束或唯一性约束。
        -   外键字段和主键字段的类型要一致，长度可以不同。
        -   主表已被引用的记录，不能直接删除。
    -   约束等级（默认限制删除）：
        -   `cascade`（级联）：更新/删除父表的记录，子表也会一起更新(外键字段)/删除。
        -   `set null`：更新/删除父表的记录，子表匹配的列将设为空（不能有非空约束）。
        -   `no action`：如果子表有记录，父表不允许更新/删除。
        -   `restrict`：同no action。

**添加约束：**

1.  约束分为列级约束和表级约束。
2.  列级约束和字段一起定义，表级单独定义。
3.  如果涉及到多个字段的约束，必须定义为表级约束。
4.  其他约束可以定义为列级，也可以定义为表级。

```sql
create table <表名>(
  <字段名> <数据类型> primary key,      -- 主键
  <字段名> <数据类型> not null,         -- 非空约束
  <字段名> <数据类型> check (条件),        -- 检查器
  <字段名> <数据类型> default <默认值>,    -- 默认值
  primary key (字段1, 字段2),            -- 复合主键（两个字段看做一个主键）
  foreign key (外键字段) references <主表>(主表字段)    -- 外键约束
);
```

### 2.1.3 自动递增

> 新记录的数值自动+1

注意：

1.  只能给整型字段使用。
2.  添加记录时，自增字段输入NULL。
3.  数值默认由1开始。
4.  如果添加了别的值，则按该列的最大值的+1。

```sql
create table from <表名>(
  <字段名> <数据类型> auto_increment,
);
```

指定初始值：

```sql
auto_increment = 100
```

## 2.2 修改表结构

查看表结构：

```sql
desc <表名>;    -- 全称：describe
```

添加字段：

```sql
alter table <表名> add <字段名> <类型(长度)> [完整性约束];

```

修改字段：

```sql
alter table <表名> modify <字段名> <类型(长度)> [完整性约束];
```

删除字段：

```sql
alter table <表名> drop <字段名>;
```

修改字段名：

```sql
alter table <表名> change <原字段名> <新字段名> <类型(长度)> [完整性约束];
```

修改表名：

```sql
rename table <原表名> to <新表名>;
```

```sql
alter table <原表名> rename <新表名>;
```

## 2.3 修改表数据

### 2.3.1 插入记录

> 字段名与值一一对应。

```sql
insert into <表名>(字段1, 字段2) values (值1, 值2);
```

省略字段名：

> 省略字段名后，默认填写全部字段。

```sql
insert into <表名> values (值1, 值2);
```

一条语句插入多行记录：

```sql
insert into <表名> values (值1, 值2), (值1, 值2);
```

### 2.3.2 修改记录

> 默认修改所有记录，需要使用where进行筛选。

```sql
update <表名> set <字段名>=值;
```

同时修改多个字段的值：

```sql
update <表名> set 字段1=值, 字段2=值;
```

### 2.3.3 删除记录

> 默认删除所有记录，需要使用where进行筛选。

```sql
delete from <表名>;
```

## 2.4 删除表

删除表：

```sql
drop table <表名>;
```

如果表存在，则删除该表（不会报错）：

```sql
drop table if exists <表名>;
```

# 3. 查询

**书写顺序：**

> SELECT -> DISTINCT -> FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> LIMIT

> 注意：使用单引号标识字符串，更通用和符合标准。

查询表中所有记录：

```sql
select * from <表名>;
```

显示指定字段：

```sql
selec 字段1,字段2 from <表名>;
```

指定别名：

> 别名有空格，使用引号括起来。

```sql
select <字段> as <别名> from <表名>;

```

```sql
<字段> <别名>    -- as 可以省略，使用空格分隔
```

使用表达式对结果进行运算：

```sql
select 字段*10 as <别名> from <表名>;
```

过滤重复的数据：

```sql
select distinct <字段名> from <表名>;
```

只显示前几条记录：

```sql
select * from <表名> limit <数字>;

```

指定显示哪几行记录：

```sql
select * from <表名> limit <开始行, 总行数>;    -- 第一条记录用0表示
```

## 3.1 条件查询

用法：

```sql
select * from <表名> where <条件表达式>;
```

运算符：

| **比较运算符**  | `>`、`<`、`<=`、`=`、`<>`、`!=`                                                                |
| ---------- | ----------------------------------------------------------------------------------------- |
| **其他比较运算** | - `between and`&#xA;- `in`、`not in`&#xA;- `like`、`not like`&#xA;- `is null`、`is not null` |
| **逻辑运算符**  | `and`、`or`、`not`                                                                          |

> `<>` 和 `!=` 都是不等于。

使用比较运算符：

```sql
where 字段 = 值;
```

日期型比较：

```sql
where `date` > '2012-12-21';
```

模糊查询：

```sql
where <字段名> like '张%';
  %    -- 任意字符（0~n个）
  _    -- 任意一个字符

```

范围查找：

```sql
where <字段名> between 10 and 20;    -- 查找10~20的范围
```

列表查询：

> 判断值是否属于该集合。

```sql
where <字段名> in (xx, xx, xx);
```

正则表达式：

```sql
where <字段名> regexp '正则';
```

## 3.2 排序

按指定字段排序（默认升序）：

```sql
select * from <表名> order by <字段名>;

```

降序排列：

```sql
select * from <表名> order by <字段名> desc;
```

使用别名进行排序：

> where 不能用别名筛选。

```sql
select (字段1+字段2) as <别名> from <表名> order by <别名>;
```

多字段排序：

> 当字段1有相同值，就会在当前排序的基础上，按字段2进行排序。

```sql
select * from <表名> order by 字段1, 字段2;
```

## 3.3 内置函数

### 3.3.1 文本处理函数

| **函数名**       | **作用**  | **语法**             | **说明**           |
| ------------- | ------- | ------------------ | ---------------- |
| **Substr()**  | 截取字符串   | (字段名,开始位置,截取长度)    | 不能截取函数，位置从1开始    |
| **Replace()** | 替换字符串   | (字段名,查找字符,替换字符)    |                  |
| **Concat()**  | 字符串拼接   | (string1, string2) |                  |
| **Trim()**    | 去除前后空格  |                    |                  |
| **Ltrim()**   | 去除左边的空格 |                    |                  |
| **Rtrim()**   | 去除右边的空格 |                    |                  |
| **Left()**    | 截取左边的字符 | (字段名, 截取长度)        |                  |
| **Right()**   | 截取右边的字符 | (字段名, 截取长度)        |                  |
| **Length()**  | 返回字符串长度 | (字段名)              | 按字节算，一个汉字占3字节    |
| **Upper()**   | 转换为大写   |                    |                  |
| **Lower()**   | 转换为小写   |                    |                  |
| **MD5()**     | 加密      |                    | MD5是不可逆的，加密后32字节 |

### 3.3.2 数学函数

| **函数名**       | **作用** | **语法**         | **说明**                 |
| ------------- | ------ | -------------- | ---------------------- |
| **abs()**     | 绝对值    |                |                        |
| **format()**  | 四舍五入   | (数值,小数长度)      |                        |
| **ceiling()** | 向上取整   |                |                        |
| **floor()**   | 向下取整   |                |                        |
| **bin()**     | 转二进制   |                |                        |
| **hex()**     | 转十六进制  |                |                        |
| **conv()**    | 转为指定进制 | (原数值,原进制,目标进制) | 参加均为数值                 |
| **mod()**     | 求余     |                |                        |
| **sqrt()**    | 求平方根   |                |                        |
| **exp()**     | 求指数    |                |                        |
| **rand()**    | 随机数    |                | 范围：0\~1，固定随机数：rand(数值) |
| **least()**   | 取最小值   | (xx,xx,xx)     |                        |

### 3.3.3 日期时间函数

| **函数名**                  | **作用**   | **语法**              | **说明**     |
| ------------------------ | -------- | ------------------- | ---------- |
| **current\_date()**      | 当前日期     |                     |            |
| **current\_time()**      | 当前时间     |                     |            |
| **current\_timestamp()** | 当前日期时间   |                     |            |
| **now()**                | 当前日期时间   |                     |            |
| **datediff()**           | 求相差天数    | ('日期1','日期2')       | 使用日期1减日期2  |
| **date\_add()**          | 加上一个时间   | (日期,interval 数值 单位) | 单位：时间单位英文名 |
| **date\_sub()**          | 减去一个时间   | (日期,interval 数值 单位) |            |
| **date\_format()**       | 格式化显示日期  | (日期,'%Y-%m-%d')     |            |
| **date()**               | 提取日期部分   | (日期时间)              |            |
| **year()**               | 提取年份     |                     |            |
| **month**                | 提取月份     |                     |            |
| **day()**                | 提取天数     |                     |            |
| **time()**               | 提取时间     |                     |            |
| **Second()**             | 提取秒      |                     |            |
| **DayOfWeek()**          | 返回星期几    |                     |            |
| **unix\_timestamp()**    | 时间戳      |                     |            |
| **form\_unixtime()**     | 时间戳转日期   | (时间戳,'%Y-%m-%d')    |            |

### 3.3.4 流程控制函数

| **函数名**      | **作用** | **语法**         | **说明**                       |
| ------------ | ------ | -------------- | ---------------------------- |
| **If()**     | 条件判断   | (条件,表达式1,表达式2) | 条件为真，返回表达式1，否则返回表达式2         |
| **IfNull()** | 是否为空   | (表达式1,表达式2)    | 表达式1不为空，返回表达式1，&#xA;为空返回表达式2 |

多条件判断：

> 类似if .. else if ... else 的结构

```sql
select 
  case
    when <条件> then <返回值>
    when <条件> then <返回值>
    else <返回值> 
  end
from <表名>;
```

### 3.3.5 聚合函数

> 对所有记录进行处理，如`sum(字段名)`对该列的所有行进行求和。

| **函数名**     | **作用** | **说明** |
| ----------- | ------ | ------ |
| **sum()**   | 求和     |        |
| **max()**   | 求最大值   |        |
| **min()**   | 求最小值   |        |
| **avg()**   | 求平均值   | 忽略null |
| **count()** | 统计行数   |        |

统计行数：

```sql
select count(*) from <表名>;
```

统计该列的非空值个数：

```sql
select count(字段名) from <表名>;
```

忽略重复值：

```sql
select count(dictinct <字段名>) from <表名>;
```

## 3.4 分组查询

> 分组查询对每组数据分别进行查询。

注意：

-   分组查询需要搭配聚合函数。
-   group by 必须写在where 之后，order by之前。
-   select中的字段只能是分组字段和汇总字段。

基本用法：

```sql
select 分组字段, 聚合函数(*) from <表名> group by <字段名>;
```

按多个字段分组：

> 先按字段1分组，在每一组之中，再按照字段2分组。

```sql
select 分组字段1, 分组字段2, count(*) from <表名> group by 字段1, 字段2;
```

对分组前数据进行筛选：

> where 不能使用聚合函数。

```sql
select 分组字段, count(*) from <表名> where <条件> group by <字段名>;
```

对分组后的数据进行筛选：

```sql
select 分组字段, count(*) from <表名> group by <字段名> having count(*)>3
```

## 3.5 多表查询

交叉查询（笛卡尔积）：

> 表1的每条记录和表2 的每条记录相连。

```sql
select * from 表1, 表2;
```

### 3.5.1 内连接

```sql
表名.字段名   -- 选择表中的字段
表名.*       -- 表中所有字段
```

等值连接（SQL 89标准）：

> 使用两张表共有的字段进行筛选，避免笛卡尔积。

```sql
select * from 表1, 表2 where 表1.id = 表2.id;
```

等值连接（SQL 99 标准）：

> 使用 join 进行表连接，on 进行连接条件筛选（使连接条件独立）。

```sql
select * from 表1 inner join 表2 on <连接条件>;    -- inner 可以省略（加上逻辑更清晰）
```

非等值连接：

```sql
on 表1.字段 < 表2.字段;
```

自连接：

> 自己和自己连接，把一张表看成两张表。

```sql
select 别名1.字段名, 别名2.字段名 
  from <表名> as 别名1, <表名> as 别名2;
```

三表连接：

```sql
select * 
  from 表1
  join 表2 on <条件>    -- 表1和表2的连接条件
  join 表3 on <条件>;   -- 连接后的新表和表3连接

```

### 3.5.2 外连接

外连接的分类：左外连接、右外连接。

左外连接：

> 左侧的表完全显示，即使不符合条件。

```sql
select * from <表1> left join <表2> on 表1.id = 表2.id;
```

右外连接：

> 右侧的表完全显示，即使不符合条件。

```sql
select * from <表1> right join <表2> on 表1.id = 表2.id;
```

### 3.5.3 联合查询

> 将两个查询的结果上下合并。`union all`保留重复行，`union`合并重复行。

```sql
select * from <表名> 
  union all
  select * from <表名>;
```

## 3.6 子查询（嵌套查询）

单行子查询：

> 使用子查询返回的结果进行查询。

```sql
select * from <表名> where id=(
  select id from <表名> where name='xx';
);
```

多行子查询：

> 结果有多条记录，使用in进行判断。

```sql
select * from <表名> where in (
  子查询
);
```

通过子查询插入另一个表的数据：

```sql
insert into <表名> (
  select * from <表名>
);
```

# 4. 索引

## 4.1 索引的概念

**索引的作用：**

-   索引可以减少读取磁盘的次数，避免全表扫描。
-   索引文件会重新排序数据，大幅度优化查询速度，用空间换时间。

**索引的分类：**

-   主键索引：添加主键约束后，会自动创建该索引。
-   唯一索引：添加唯一性约束后，会自动创建该索引。
-   普通索引：允许重复数据。
-   全文索引：查找文章中的内容。一般不适用MySQL自带的全文索引。而是使用全文搜索Solr和ElasticSearch。

**注意：**

-   一个索引只对一个字段有效，要查询其他字段需要再创建索引。
-   修改记录会对索引产生影响。

**需要索引的字段：**作为条件频繁查询的字段。

**不适合创建索引的字段：**

-   唯一性太差的字段不适合。
-   更新频繁的字段不适合。

**索引未被使用的原因：**

-   索引键的重复率很高。查询返回的结果数量很多（大于1%），一般使用全表扫描
-   查询条件中的索引列使用了函数。
-   字符串列使用了模糊查询，且通配符在第一个位置

**影响查询效率的因素：**

-   CPU 处理时间
-   读内存时间
-   读硬盘时间（主要因素，取决于读取磁盘的次数）
-   网络传输时间

## 4.2 创建索引

创建普通索引：

```sql
create index <索引名> on <表名(字段名)>;
```

```sql
alter table <表名> add index <索引名> (字段名);
```

创建唯一索引：

```sql
create unique <索引名> on <表名(字段名)>;
```

创建主键索引：

```sql
alter table <表名> add primary key (字段名);
```

查看索引信息：

```sql
show index from <表名>;
```

在创建表时建立索引：

```sql
create table <表名> (
  ...
  unique index 索引名(字段名);
)

```

## 4.3 删除索引

> 索引不能修改，只能删除后重新创建。

删除索引：

```sql
drop index <索引名> on <表名>;
```

删除主键索引：

```sql
alter table <表名> drop primary key;
```

# 5. 触发器

MySQL从5.0.2版本开始支持触发器。

触发器概述：

-   触器由事件出触发，如：insert、update、delete事件。触发后将会执行响应的操作。
-   当插入、更新、删除数据时，需要自动执行一些操作，就可以使用触发器实现。

## 5.1 创建触发器

-   before：执行事件之前触发。
-   after：执行事件之后触发。

```sql
create trigger <触发器名称>
  <before|after>      -- 触发时间（事件之前触发，或事件之后触发）
  <insert|update|delete> on 表名    -- 触发事件
  for each row        -- 行级触发（不可省略）
  <SQl语句>;           -- 触发器执行的语句（多条SQL语句使用 begin 和 end 包裹）

```

## 5.2 NEW 和 OLD

> 注意：想要修改触发事件的记录，需要在执行事件前修改。

别名new 和 old 表示修改前和修改后的数据。

使用方法：

```sql
set new.字段=值
```

| insert | new表示将要插入或已经插入的数据          |
| ------ | -------------------------- |
| update | old表示修改之前的数据，new 表示修改之后的数据 |
| delete | old 表示将要删除或已经删除的数据         |

# 6. 视图

视图的说明：

-   图是一个虚拟表，其内容由查询定义。
-   视图的数据来自一张或多张基表（真实表）。
-   通过视图可以修改基表的数据，修改基表也会影响视图的数据。
-   视图可以像表一样进行操作，使用SQL进行增删查改。

视图的作用：

-   安全性：一些表有着重要的字段，不想让用户看到。使用视图可以只保留部分字段，这样用户只能查询公开的字段。
-   性能：频繁使用 JOIN 进行多表查询，效率相对较低。通过建立一个视图，可以避免使用 JOIN 查询数据。
-   灵活：如果系统中有张旧表，因为设计问题即将废弃，但有很多应用依赖这张表。这时候就可以创建一张视图，将数据映射到视图，这样就能达到升级数据表的目的。

创建视图（MySQL）：

```sql
create view <视图名> as <select 语句>;
```

创建视图（Oracle）：

```sql
CREATE OR REPLACE VIEW <视图名> AS <select 语句>;

```

更换视图：

```sql
alter view <视图名> as <select 语句>;
```

查看创建视图的语句：

```sql
show create view <视图名>;
```

删除视图（可以删除多个）：

```sql
drop view <视图名>;
```

# 7. 事务

**事务的操作方式：**

1.  开始事务。
2.  设置保存点：在执行多条 DML 语句的过程中，手动设置保存点。
3.  回滚事务：
    -   如果执行 DML 语句失败，手动跳转保存点（回滚）。
    -   跨多个保存点回退后，将删除后面的保存点。
4.  提交事务：
    -   提交事务（commit）后，将结束此次事务。
    -   结束的过程：确认事务的变化、结束事务、删除保存点、释放锁、数据生效。
    -   结束事务后，其他会话才能看到修改后的新数据。

**注意：**

-   如果不开启事务，DML 操作默认是自动提交，不能回滚。
-   InnoDB 存储引擎支持事务，MyISAM 不支持。

## 7.2 **事务的操作**

开启事务：

```sql
START TRANSACTION;
```

```sql
set autocommit=off;
```

设置保存点：

```sql
SAVEPOINT <保存点名>;
```

回退事务：

```sql
ROLLBACK TO <保存点名>;
```

回退全部事务（回退到事务开始的状态）：

```sql
ROLLBACK;
```

提交事务（所有操作生效，删除所有保存点，不能回退）

```sql
COMMIT;
```

## 7.3 事务隔离级别

多个连接开启各自的事务操作数据库，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。

**三种并发问题：**

-   脏读：一个事务读到另一个事务的还没提交的数据。
-   不可重复读：当一个事务进行时，读取到另一个事务提交的数据（修改、删除），获取的数据与事务开始时不一致，造成不可重复读。
-   幻读：当一个事务进行时，由于其他事务提交了插入操作，造成每次查询结果不同，发生幻读。

**MySQL 事务隔离级别：**

| **隔离级别**                    | **脏读** | **不可重复读** | **幻读** | **是否加锁** |
| --------------------------- | ------ | --------- | ------ | -------- |
| 读未提交&#xA;（read uncommitted） | √      | √         | √      | 不加锁      |
| 读已提交&#xA;（read committed）   | ×      | √         | √      | 不加锁      |
| 可重复读&#xA;（repeatable read）  | ×      | ×         | ×      | 不加锁      |
| 可串行读&#xA;（serializable）     | ×      | ×         | ×      | 加锁       |

查看当前隔离级别：

```sql
-- MySQL 5.7
select @@tx_isolation;
```

```sql
-- MySQL 8
select @@transaction_isolation;
```

# 8. 存储过程

存储过程的介绍：

-   存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合。
-   存储过程是数据库 SQL 语言层面的代码封装和重用。

存储过程的特点：

-   调用存储过程可以减少数据在数据库和应用程序之间的传输，提高数据处理的效率。
-   存储过程可以接受参数，也可以返回数据。

创建存储过程（MySQL）：

> 参数可以省，括号不能省。

```sql
create procedure <存储过程名([参数列表])>
begin
  <sql 语句>
end;
```

创建存储过程（Oracle）：

```sql
CREATE OR REPLACE PROCEDURE <存储过程名([参数列表])> AS
BEGIN
  <sql 语句>
END;

```

调用存储过程：

```sql
call <存储过程名([参数列表])>;
```

查看创建的存储过程：

```sql
SELECT * FROM information_schema.ROUTINES WHERE  routine_schema = '数据库名';
```

查看创建存储过程的语句：

```sql
show create procedure <存储过程名>;
```

删除存储过程：

```sql
drop procedure <存储过程名>;
```
